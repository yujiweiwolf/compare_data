#pragma once

#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <memory>

namespace co {

    // +---------- DO NOT EDIT BEGIN ----------+
    // Generated by GenerateCodeIndexConstants().  DO NOT EDIT!
    constexpr int64_t kCodeIndexBeginSH = 0;
    constexpr int64_t kCodeIndexEndSH = 1000000;
    constexpr int64_t kCodeIndexBeginSZ = 1000000;
    constexpr int64_t kCodeIndexEndSZ = 2000000;
    constexpr int64_t kCodeIndexBeginBJ = 2000000;
    constexpr int64_t kCodeIndexEndBJ = 3000000;
    constexpr int64_t kCodeIndexBeginCSI = 3000000;
    constexpr int64_t kCodeIndexEndCSI = 4000000;
    constexpr int64_t kCodeIndexBeginCNI = 4000000;
    constexpr int64_t kCodeIndexEndCNI = 5000000;
    constexpr int64_t kCodeIndexBeginHK = 5000000;
    constexpr int64_t kCodeIndexEndHK = 5100000;
    constexpr int64_t kCodeIndexBeginCFFEX1 = 5100000;
    constexpr int64_t kCodeIndexEndCFFEX1 = 5126624;
    constexpr int64_t kCodeIndexBeginCFFEX2 = 5126624;
    constexpr int64_t kCodeIndexEndCFFEX2 = 5818848;
    constexpr int64_t kCodeIndexBeginSHFE1 = 5818848;
    constexpr int64_t kCodeIndexEndSHFE1 = 5845472;
    constexpr int64_t kCodeIndexBeginSHFE2 = 5845472;
    constexpr int64_t kCodeIndexEndSHFE2 = 6537696;
    constexpr int64_t kCodeIndexBeginDCE1 = 6537696;
    constexpr int64_t kCodeIndexEndDCE1 = 6564320;
    constexpr int64_t kCodeIndexBeginDCE2 = 6564320;
    constexpr int64_t kCodeIndexEndDCE2 = 7256544;
    constexpr int64_t kCodeIndexBeginCZCE1 = 7256544;
    constexpr int64_t kCodeIndexEndCZCE1 = 7283168;
    constexpr int64_t kCodeIndexBeginCZCE2 = 7283168;
    constexpr int64_t kCodeIndexEndCZCE2 = 7975392;
    constexpr int64_t kCodeIndexBeginGFE1 = 7975392;
    constexpr int64_t kCodeIndexEndGFE1 = 8002016;
    constexpr int64_t kCodeIndexBeginGFE2 = 8002016;
    constexpr int64_t kCodeIndexEndGFE2 = 8694240;
    constexpr int64_t kCodeIndexBeginINE1 = 8694240;
    constexpr int64_t kCodeIndexEndINE1 = 8720864;
    constexpr int64_t kCodeIndexBeginINE2 = 8720864;
    constexpr int64_t kCodeIndexEndINE2 = 9413088;
    constexpr int64_t kCodeIndexBeginSGE1 = 9413088;
    constexpr int64_t kCodeIndexEndSGE1 = 9439712;
    constexpr int64_t kCodeIndexBeginSGE2 = 9439712;
    constexpr int64_t kCodeIndexEndSGE2 = 10131936;

    constexpr int64_t kCodeIndexArraySize = 10131936;
    constexpr int64_t kCodeIndexMin = 1;
    constexpr int64_t kCodeIndexMax = 10131935;
    // +---------- DO NOT EDIT END   ----------+

    constexpr int64_t kCodeIndexEncodedMonthBits = 10;  // 10个二进制位存储编码后的月份
    constexpr int64_t kCodeIndexEncodedMonthMax = 1023;  // 编码后月份的最大值
    constexpr int64_t kCodeIndexMonthMax = 8504; // 支持的最大月份：2085年04月

    bool IsValidCodeIndex(int64_t code_index);
    int64_t CodeToIndex(const char* code, int code_size = -1);
    int64_t CodeToIndex(const std::string_view& code);
    int64_t CodeToIndex(const std::string& code);
    bool IndexToCode(int64_t code_index, char* out_data, int out_size);
    std::string IndexToCode(int64_t code_index);


    template <typename T>
    struct CodeMapPointerExtractor {
        static T* Get(T& val) {
            return &val;
        }
    };

    template <typename T>
    struct CodeMapPointerExtractor<T*> {
        static T* Get(T* val) {
            return val;
        }
    };

    template <typename T>
    struct CodeMapPointerExtractor<std::unique_ptr<T>> {
        static T* Get(const std::unique_ptr<T>& val) {
            return val.get();
        }
    };

    template <typename T>
    struct CodeMapPointerExtractor<std::shared_ptr<T>> {
        static T* Get(const std::shared_ptr<T>& val) {
            return val.get();
        }
    };

    /**
     * 代码映射模板
     * @tparam Key
     * @tparam T
     * @since 2025-04-10 15:24:46
     */
    template<class Key, class T>
    class CodeMap {
    public:
        using ValuePtr = decltype(CodeMapPointerExtractor<T>::Get(std::declval<T&>()));

        template<class U> ValuePtr Get(const U& q) {
            int64_t code_index = q.code_index();
            if (code_index > 0 && code_index < list_.size()) {
                return list_[code_index];
            }
            auto code = q.code();
            auto itr = map_.find(code);
            return itr != map_.end() ? CodeMapPointerExtractor<T>::Get(itr->second) : nullptr;
        }

        void Set(const char* code, T value) {
            ValuePtr value_ptr = CodeMapPointerExtractor<T>::Get(value);
            int64_t code_index = co::CodeToIndex(code);
            if (code_index > 0 && code_index <= co::kCodeIndexMax) {
                if (code_index >= list_.size()) {
                    // 分配kCodeIndexEndCFFEX2大小耗时大概50ms
                    list_.resize(code_index < co::kCodeIndexEndCFFEX2
                                 ? co::kCodeIndexEndCFFEX2
                                 : co::kCodeIndexMax + 1,
                                 nullptr);
                }
                list_[code_index] = value_ptr;
            }
            map_[code] = std::move(value);
        }

        void Set(const std::string_view& code, T value) {
            ValuePtr value_ptr = CodeMapPointerExtractor<T>::Get(value);
            int64_t code_index = co::CodeToIndex(code.data(), code.size());
            if (code_index > 0 && code_index <= co::kCodeIndexMax) {
                if (code_index >= list_.size()) {
                    list_.resize(code_index < co::kCodeIndexEndCFFEX2
                                 ? co::kCodeIndexEndCFFEX2
                                 : co::kCodeIndexMax + 1,
                                 nullptr);
                }
                list_[code_index] = value_ptr;
            }
            map_[code] = std::move(value);
        }

        void Set(const std::string& code, T value) {
            ValuePtr value_ptr = CodeMapPointerExtractor<T>::Get(value);
            int64_t code_index = co::CodeToIndex(code.data(), code.size());
            if (code_index > 0 && code_index <= co::kCodeIndexMax) {
                if (code_index >= list_.size()) {
                    list_.resize(code_index < co::kCodeIndexEndCFFEX2
                                 ? co::kCodeIndexEndCFFEX2
                                 : co::kCodeIndexMax + 1,
                                 nullptr);
                }
                list_[code_index] = value_ptr;
            }
            map_[code] = std::move(value);
        }

        ValuePtr Get(const char* code, int64_t code_index)  {
            if (code_index > 0 && code_index < list_.size()) {
                return list_[code_index];
            }
            if (!code) {
                return nullptr;
            }
            auto itr = map_.find(code);
            return itr != map_.end() ? CodeMapPointerExtractor<T>::Get(itr->second) : nullptr;
        }

        ValuePtr Get(const std::string_view& code, int64_t code_index) {
            if (code_index > 0 && code_index < list_.size()) {
                return list_[code_index];
            }
            auto itr = map_.find(code);
            return itr != map_.end() ? CodeMapPointerExtractor<T>::Get(itr->second) : nullptr;
        }

        ValuePtr Get(const std::string& code, int64_t code_index) {
            if (code_index > 0 && code_index < list_.size()) {
                return list_[code_index];
            }
            auto itr = map_.find(code);
            return itr != map_.end() ? CodeMapPointerExtractor<T>::Get(itr->second) : nullptr;
        }


        [[nodiscard]] bool Has(const char* code, int64_t code_index) {
            return Get(code, code_index) != nullptr;
        }

        [[nodiscard]] bool Has(const std::string_view& code, int64_t code_index) {
            return Get(code, code_index) != nullptr;
        }

        [[nodiscard]] bool Has(const std::string& code, int64_t code_index) {
            return Get(code, code_index) != nullptr;
        }

        [[nodiscard]] int64_t Size() const {
            return map_.size();
        }

        [[nodiscard]] bool Empty() const {
            return map_.empty();
        }

        void Clear() {
            list_.clear();
            map_.clear();
        }

        typename std::unordered_map<Key, T>::iterator begin() {
            return map_.begin();
        }

        typename std::unordered_map<Key, T>::iterator end() {
            return map_.end();
        }

    protected:
        std::unordered_map<Key, T> map_;
        std::vector<ValuePtr> list_;
    };

}